# Technical Specification: NanoScale

**Codename:** NanoScale  
**Version:** 1.2.0-Security-Hardened  
**License:** AGPL-3.0

**Related Documents:**

- [UI Specification](ui-specification.md)
- [Code Style Guide](code-style-guide.md)
- [Development Roadmap](development-roadmap.md)
- [Installation & Run Guide](installation-and-run-guide.md)

## 1. System Architecture & Technology Stack

NanoScale operates as a Multi-Node PaaS. It allows a user to manage a cluster of VPS instances from a single dashboard.

### 1.1 Node Roles

The system is composed of two types of nodes:

#### The Orchestrator (Master Node)

- Hosts the Dashboard (Next.js Control Plane).
- Hosts the Primary Database (SQLite).
- Acts as the central command center.
- Can also host applications (acts as a local worker).

#### Worker Nodes (Child Nodes)

- Managed by the Orchestrator.
- Run the NanoScale Agent (Rust).
- Host the actual user applications (Next.js/Node.js).
- Do not host the Dashboard or Database.

### 1.2 The Stack

#### Frontend (Control Plane - Orchestrator Only)

- **Framework:** Next.js 16+ (App Router)
- **Language:** TypeScript 5.x
- **Package Manager:** Bun 1.x (workspaces)
- **UI Components:** ShadCN UI (Radix Primitives)
- **Styling:** Tailwind CSS
- **Specification:** See [ui-specification.md](ui-specification.md) for the detailed page-by-page breakdown and component requirements.

#### Backend (Host Agent & API - All Nodes)

- **Language:** Rust (2021 Edition)
- **Web Framework:** Axum 0.7
- **Database:** SQLite 3 (SQLx) - Orchestrator only stores global state; Workers use in-memory or local SQLite for transient state.
- **Communication:** HTTP/2 over TLS (Orchestrator <-> Worker)
- **Auth:** HMAC-SHA256 signatures using a unique Cluster Secret
- **Runtime:** Runs as dedicated user `nanoscale` with scoped sudo privileges
- **Code Standards:** See [code-style-guide.md](code-style-guide.md) for strict linting, architecture, and formatting rules.

#### Toolchain Version Pinning

- **Rust Toolchain:** Pinned to `1.93.0` via `rust-toolchain.toml` (with `rustfmt` and `clippy` components).
- **Bun Runtime/Package Manager:** Pinned to `1.2.20` via `.bun-version` and root `package.json` `packageManager` field.
- **CI Parity:** GitHub Actions must use pinned toolchain versions (no `latest`) to ensure lint/build consistency with local development.

### 1.3 Source Code Monorepo Structure

```text
nanoscale/
├── apps/
│   └── dashboard/                  # Next.js 16 (Runs on Orchestrator only)
├── crates/
│   └── agent/                      # Rust Axum (Runs on ALL nodes)
│       ├── src/
│       │   ├── api/                # Endpoints
│       │   ├── cluster/            # Logic for Master/Worker communication
│       │   ├── deployment/         # Deployment logic
│       │   ├── security/           # Input sanitization, signature verification
│       │   └── system/             # Systemd/Nginx wrappers
├── scripts/
│   ├── install.sh                  # Supports --role orchestrator OR --join <token>
│   └── security/
│       └── sudoers.d/nanoscale     # Strict sudo rules
```

### 1.4 Security & Permissions Model

Security is the primary design constraint. The system assumes that any user-deployed application is potentially malicious.

#### Least Privilege Runtime

- The Agent runs as `nanoscale` (unprivileged).
- It cannot modify system files outside of `/opt/nanoscale`.
- It cannot install system packages (`apt/yum`).

#### Strict Sudoers Configuration

- The Agent uses `sudo -n` for privileged tasks.
- Wildcards are restricted to specific prefixes.

Allowed commands:

- `systemctl {action} nanoscale-*` (prevents stopping `sshd` or critical services).
- `service nginx reload` (no config editing allowed via sudo, only file moves).
- `useradd/userdel` with specific name prefixes (`nanoscale-*`).
- `mv /opt/nanoscale/tmp/* /etc/nginx/sites-available/` (ensures content is generated by Agent, not arbitrarily written).

#### Command Injection Prevention

- **Rule:** Never use `sh -c` or `system()` with user input.
- **Implementation:** Use Rust's `std::process::Command` with separated arguments.
- **Validation:** All inputs (Repo URL, Branch, Project Name) are validated against strict regex allowlists (`^[a-zA-Z0-9-_]+$`) before processing.

## 2. File System Structure

| Path | Purpose | Permissions |
| --- | --- | --- |
| `/opt/nanoscale/` | Root directory | `nanoscale:nanoscale` |
| `/opt/nanoscale/bin/agent` | The Rust binary | `root:root` (immutable) |
| `/opt/nanoscale/data/` | Database directory | `nanoscale:nanoscale` |
| `/opt/nanoscale/config/` | Config directory | `nanoscale:nanoscale` |
| `/opt/nanoscale/sites/{id}/` | App source code | `nanoscale-{id}:nanoscale-{id}` |
| `/etc/systemd/system/nanoscale-agent.service` | Main Agent Service | `root:root` |

**Critical Note:** The `sites` directory is owned by the specific project user, not the agent. The agent uses sudo to manipulate these files during build, ensuring isolation.

## 3. Database Schema (SQLite - Orchestrator Only)

### 3.1 `servers` table

Tracks all nodes in the cluster.

```sql
CREATE TABLE servers (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    ip_address TEXT NOT NULL,
    status TEXT NOT NULL,
    secret_key TEXT NOT NULL,             -- High-entropy key for HMAC signing
    public_key TEXT,                      -- WireGuard/mTLS public key (Future)
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

### 3.2 `projects` table (UPDATED)

```sql
CREATE TABLE projects (
    id TEXT PRIMARY KEY,
    server_id TEXT NOT NULL,
    name TEXT NOT NULL UNIQUE,            -- Validated: ^[a-z0-9-]+$
    repo_url TEXT NOT NULL,               -- Validated: HTTPS only
    branch TEXT DEFAULT 'main',
    node_version TEXT DEFAULT '20',
    install_command TEXT DEFAULT 'bun install --frozen-lockfile',
    build_command TEXT DEFAULT 'bun run build',
    start_command TEXT DEFAULT 'bun run start',
    env_vars TEXT NOT NULL,               -- Encrypted at rest (Future)
    port INTEGER NOT NULL,
    domain TEXT,
    scale_to_zero BOOLEAN DEFAULT 1,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(server_id) REFERENCES servers(id)
);
```

## 4. API Specification

### 4.1 Security Protocols

#### Internal API (Port 4000)

- **Binding:** `0.0.0.0` (to allow cluster communication)
- **Firewall:** `ufw` rules added during install to allow Port 4000 only from Orchestrator IP (if static), or open globally with strict application-level auth.
- **Authentication:** `X-Cluster-Signature` header
- **Format:** `HMAC-SHA256(Body + Timestamp, SecretKey)`
- **Replay Protection:** Requests with timestamp > 30s old are rejected.
- **Encryption:** Self-signed TLS certs generated during `install.sh` (or Let's Encrypt if domain provided).

### 4.2 API Endpoints (Summarized)

- `POST /api/cluster/join` (Orchestrator): Exchange Token for Secret.
- `POST /internal/deploy` (Worker): Authenticated command to run build.

## 5. Threat Model & Mitigations

### 5.1 Identified Attack Vectors

| Vector | Description | Probability | Mitigation Strategy |
| --- | --- | --- | --- |
| Malicious Package Script | User deploys a `package.json` with `"postinstall": "rm -rf / --no-preserve-root"` | High | User Isolation: Builds run as `nanoscale-{id}` user. Systemd hardening: service units use `ProtectSystem=strict`, `ProtectHome=yes`. |
| Command Injection | User names a branch `; cat /etc/shadow` to execute shell commands. | Medium | No shell execution: Rust `Command::new("git").arg("checkout").arg(branch)` handles escaping automatically. Regex validation: reject inputs matching shell characters. |
| Orchestrator Compromise | Attacker gains control of Dashboard. | Low | Agent autonomy: Agents do not expose "Run Command" endpoints. They only expose "Deploy Repo" endpoints. Attacker can deploy bad code, but cannot easily root the worker. |
| Worker Escalation | Compromised app tries to read another app's env vars. | High | File permissions: `/opt/nanoscale/sites/{id}` is `0700` (readable only by owner). Environment injection: env vars are written to `/etc/default/nanoscale-{id}`, readable only by root (read by systemd) and the specific user. |
| DDoS on Dashboard | Flooding the control plane. | Medium | Rate limiting: Axum middleware limits requests/IP. Static export: dashboard is static files; API is the only attack surface. |

### 5.2 Systemd Sandbox (The Final Defense)

The generated `/etc/systemd/system/nanoscale-{id}.service` file MUST include these security directives:

```ini
[Service]
# ... basic settings ...

# SECURITY HARDENING
# The app cannot write to /usr, /boot, /etc
ProtectSystem=strict
# The app cannot see /home
ProtectHome=yes
# The app gets its own /tmp
PrivateTmp=yes
# The app cannot escalate privileges (no sudo inside the app)
NoNewPrivileges=yes
# The app cannot see other processes
ProtectProc=invisible
# Only allow writing to specific state directory (if needed)
ReadWritePaths=/opt/nanoscale/sites/{id}/source
```

## 6. Automation Logic

### 6.1 Sudoers file `/etc/sudoers.d/nanoscale`

```sudoers
# Allow restarting ONLY nanoscale services
nanoscale ALL=(root) NOPASSWD: /usr/bin/systemctl start nanoscale-*, /usr/bin/systemctl stop nanoscale-*, /usr/bin/systemctl restart nanoscale-*

# Allow reloading nginx (safe operation)
nanoscale ALL=(root) NOPASSWD: /usr/sbin/service nginx reload

# Allow user management with strict prefixes
nanoscale ALL=(root) NOPASSWD: /usr/sbin/useradd -r -s /bin/false nanoscale-*, /usr/sbin/userdel nanoscale-*

# Allow certbot (Risk: High, but necessary for SSL)
nanoscale ALL=(root) NOPASSWD: /usr/bin/certbot --nginx *
```

